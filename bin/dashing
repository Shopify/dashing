#!/usr/bin/env ruby

require 'thor'
require 'net/http'
require 'json'
require 'open-uri'

class MockScheduler
  def method_missing(*args)
    yield
  end
end

def send_event(id, data)
  req = Net::HTTP::Post.new("/widgets/#{id}")
  req["content-type"] = "application/json"
  req.body = JSON.unparse(data.merge(:auth_token => Dashing::CLI.auth_token))
  res = Net::HTTP.new('localhost', 3030).start { |http| http.request(req) }
  puts "Data Sent to #{id}: #{data}"
end

SCHEDULER = MockScheduler.new

module Dashing

  class CLI < Thor
    include Thor::Actions

    class << self
      attr_accessor :auth_token
    end

    attr_accessor :name

    no_tasks do
      ['widget', 'dashboard', 'job'].each do |type|
        define_method "generate_#{type}" do |name|
          @name = Thor::Util.snake_case(name)
          directory type.to_sym, File.join("#{type}s")
        end
      end
    end

    def self.source_root
      File.expand_path('../../templates', __FILE__)
    end

    desc "new PROJECT_NAME", "Sets up ALL THE THINGS needed for your dashboard project."
    def new(name)
      @name = Thor::Util.snake_case(name)
      directory :project, @name
    end

    desc "generate (widget/dashboard/job) NAME", "Creates a new widget, dashboard, or job."
    def generate(type, name)
      send("generate_#{type}".to_sym, name)
    rescue NoMethodError => e
      puts "Invalid generator. Either use widget, dashboard, or job"
    end 
    map "g" => :generate

    desc "install GIST_ID", "Install a new widget."
    def install(gist_id)
      gist = JSON.parse(open("https://api.github.com/gists/#{gist_id}").read)
      gist['files'].delete_if { |f| f.end_with?(".md") }.each do |n,c|        
        if(n.end_with?(".rb"))
          create_file "#{Dir.pwd}/jobs/#{n}", c['content'] 
        else
          if(n.end_with?(".coffee", ".html", ".scss"))
            widget_name = n.sub(/.[^.]+\z/, '')
            empty_directory "#{Dir.pwd}/widgets/#{widget_name}"
            create_file "#{Dir.pwd}/widgets/#{widget_name}/#{n}", c['content'] 
          end
        end
      end
      print(set_color("Don't forget to edit ", :yellow))
      print(set_color("Gemfile ", :yellow, :bold))
      print(set_color("and run ", :yellow))
      print(set_color("bundle install ", :yellow, :bold))
      say(set_color("if needed.", :yellow))
    end
    map "i" => :install

    desc "start", "Starts the server in style!"
    method_option :job_path, :desc => "Specify the directory where jobs are stored"
    def start(*args)
      port_option = args.include?('-p')? '' : ' -p 3030'
      args = args.join(" ")
      command = "bundle exec thin -R config.ru start #{port_option} #{args}"
      command.prepend "export JOB_PATH=#{options[:job_path]}; " if options[:job_path]
      system(command)
    end
    map "s" => :start

    desc "job JOB_NAME AUTH_TOKEN(optional)", "Runs the specified job. Make sure to supply your auth token if you have one set."
    def job(name, auth_token = "")
      Dir[File.join(Dir.pwd, 'lib/**/*.rb')].each {|file| require file }
      self.class.auth_token = auth_token
      f = File.join(Dir.pwd, "jobs", "#{name}.rb")
      require f
    end
  
  end
end

Dashing::CLI.start